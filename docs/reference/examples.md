# 📚 Ejemplos de Uso

## 🎯 Casos de Uso Reales

### **1. Desarrollo de Nueva Funcionalidad**

#### **Objetivo**: Implementar sistema de notificaciones en tiempo real

```bash
/context-eng "implementar sistema de notificaciones push en tiempo real con WebSockets"
```

**Resultado Automático**:
```
🔄 PHASE 0: Intelligent Routing
├── Complexity: 1.4 (Medium-High)
├── Confidence: 0.75
├── Strategy: 5-phase full orchestration
└── Duration: ~18 minutes estimated

🔄 PHASE 1: Discovery (4 minutes)
├── 🤖 Knowledge Specialist: Analyzed WebSocket patterns
├── 🤖 Pattern Specialist: Identified notification patterns
└── 📊 Results: Architecture recommendations ready

🔄 PHASE 2: Planning (5 minutes)
├── 🤖 Planning Specialist: TDD approach selected
├── 🤖 Model Specialist: Sonnet recommended (implementation focus)
└── 📊 Results: Implementation plan with milestones

🔄 PHASE 3: Execution (6 minutes)
├── 🤖 Parallel Coordinator: WebSocket + Database + Frontend
├── 🤖 Git Strategist: Feature branch with commit strategy
└── 📊 Results: Parallel implementation completed

🔄 PHASE 4: Verification (2 minutes)
├── 🤖 Test Specialist: 24/24 tests passing
├── 🤖 Performance Specialist: <200ms latency achieved
└── 📊 Results: 97% confidence, production ready

🔄 PHASE 5: Documentation (1 minute)
├── 🤖 Documentation Specialist: API docs generated
├── 🤖 Pattern Specialist: Pattern crystallized for reuse
└── 📊 Results: Living documentation updated
```

**Entregables**:
- ✅ WebSocket server implementado
- ✅ Frontend notification components
- ✅ Database schema optimizada
- ✅ Tests completos con 97% coverage
- ✅ Documentación API generada
- ✅ Patrón reutilizable creado

---

### **2. Análisis de Código Legacy**

#### **Objetivo**: Entender y documentar sistema de facturación legacy

```bash
/ce auto "analizar y documentar el sistema de facturación legacy para refactoring"
```

**Resultado Automático**:
```
🔄 ADAPTIVE ROUTING: Learning mode detected
├── Pattern: "analizar" → Quick exploration workflow
├── Confidence: 0.94 (high pattern match)
├── Strategy: 2-phase optimized (70% faster)
└── Duration: ~6 minutes estimated

🔄 PHASE 0: Quick Routing (1 minute)
├── Registry Analysis: /quick-explore optimal (94% success rate)
├── Command Selection: Exploration-focused atomic commands
└── Optimization: Skip planning overhead for analysis tasks

🔄 PHASE 3: Execution (5 minutes)
├── 🤖 Code Analyzer: Mapped 847 functions, 23 modules
├── 🤖 Dependency Specialist: Identified 12 critical paths
├── 🤖 Documentation Specialist: Generated interaction diagrams
└── 📊 Results: Complete system map with refactoring recommendations
```

**Entregables**:
- ✅ System architecture diagram
- ✅ Dependency analysis report
- ✅ Code quality assessment
- ✅ Refactoring priority matrix
- ✅ Risk assessment for changes
- ✅ Migration strategy outline

---

### **3. Performance Optimization**

#### **Objetivo**: Optimizar API que está experimentando latencia alta

```bash
/ce "optimizar API de e-commerce que tiene latencia >2000ms en endpoints críticos"
```

**Resultado Automático**:
```
🔄 PHASE 0: Intelligent Routing
├── Complexity: 1.2 (Medium)
├── Confidence: 0.82
├── Strategy: 3-phase execution (50% faster)
└── Duration: ~10 minutes estimated

🔄 PHASE 0: Routing (1 minute)
├── Decision Engine: Performance optimization pattern detected
├── Parallel Analysis: Database + Code + Infrastructure beneficial
└── Command Selection: Performance-focused orchestration

🔄 PHASE 2: Strategic Planning (3 minutes)
├── 🤖 Performance Specialist: Identified N+1 queries, cache misses
├── 🤖 Database Specialist: Index optimization strategy
├── 🤖 Architecture Specialist: Caching layer recommendations
└── 📊 Results: Multi-layer optimization plan ready

🔄 PHASE 3: Execution (6 minutes)
├── 🤖 Query Optimizer: Reduced queries from 45 to 3 per request
├── 🤖 Cache Specialist: Redis implementation with 95% hit rate
├── 🤖 Index Specialist: Database indexes optimized
└── 📊 Results: Latency reduced from 2000ms to 180ms
```

**Entregables**:
- ✅ Database queries optimized (15x reduction)
- ✅ Redis caching layer implemented
- ✅ Database indexes created
- ✅ Performance monitoring dashboard
- ✅ Load testing results
- ✅ Production deployment plan

---

### **4. Arquitectura de Microservicios**

#### **Objetivo**: Diseñar arquitectura completa para plataforma de streaming

```bash
/ce "diseñar arquitectura de microservicios para plataforma de streaming con 1M+ usuarios" model=opus
```

**Resultado Automático**:
```
🔄 PHASE 0: Intelligent Routing
├── Complexity: 1.9 (Ultra-High)
├── Confidence: 0.45 (architecture uncertainty)
├── Strategy: 5-phase complete orchestration + multi-agent
└── Duration: ~25 minutes estimated

🔄 PHASE 1: Discovery (6 minutes)
├── 🤖 Domain Specialist: Identified 8 core domains
├── 🤖 Scale Specialist: Analyzed 1M+ user requirements
├── 🤖 Technology Specialist: Evaluated 15 technology options
├── 🤖 Pattern Specialist: Streaming architecture patterns
└── 📊 Results: Comprehensive requirements and constraints

🔄 PHASE 2: Planning (8 minutes)
├── 🤖 Architecture Specialist: Service boundary definitions
├── 🤖 Data Specialist: Event sourcing + CQRS strategy
├── 🤖 Infrastructure Specialist: Kubernetes deployment plan
├── 🤖 Security Specialist: Authentication and authorization
└── 📊 Results: Detailed architecture blueprint

🔄 PHASE 3: Execution (7 minutes)
├── 🤖 Service Designer: 12 microservices designed
├── 🤖 API Designer: OpenAPI specifications created
├── 🤖 Database Designer: Database per service strategy
├── 🤖 DevOps Specialist: CI/CD pipeline architecture
└── 📊 Results: Implementation-ready architecture

🔄 PHASE 4: Verification (3 minutes)
├── 🤖 Architecture Validator: Single points of failure eliminated
├── 🤖 Performance Validator: Load testing scenarios
├── 🤖 Security Validator: Threat modeling completed
└── 📊 Results: 98% confidence, production-ready design

🔄 PHASE 5: Documentation (1 minute)
├── 🤖 Documentation Specialist: Architecture decision records
├── 🤖 Diagram Specialist: C4 model diagrams generated
└── 📊 Results: Complete architecture documentation
```

**Entregables**:
- ✅ 12 microservices architecture
- ✅ API gateway configuration
- ✅ Database design (per service)
- ✅ Event streaming architecture
- ✅ Security implementation plan
- ✅ Monitoring and observability
- ✅ Deployment infrastructure
- ✅ Scaling strategy (1M+ users)

---

### **5. Bug Fixing Crítico**

#### **Objetivo**: Resolver memory leak en producción

```bash
/ce "encontrar y corregir memory leak crítico en aplicación Node.js en producción"
```

**Resultado Automático**:
```
🔄 PHASE 0: Intelligent Routing
├── Complexity: 1.3 (Medium-High)
├── Confidence: 0.68 (debugging uncertainty)
├── Strategy: 5-phase with emphasis on discovery
└── Duration: ~15 minutes estimated

🔄 PHASE 1: Discovery (5 minutes)
├── 🤖 Memory Specialist: Heap dump analysis
├── 🤖 Code Specialist: Event listener audit
├── 🤖 Performance Specialist: Memory usage patterns
└── 📊 Results: Memory leak in WebSocket connections identified

🔄 PHASE 2: Planning (2 minutes)
├── 🤖 Strategy Specialist: Hot-fix vs comprehensive fix
├── 🤖 Risk Specialist: Production impact assessment
└── 📊 Results: Staged rollout plan with rollback strategy

🔄 PHASE 3: Execution (6 minutes)
├── 🤖 Fix Specialist: Connection cleanup implemented
├── 🤖 Test Specialist: Memory leak tests added
├── 🤖 Monitor Specialist: Memory monitoring enhanced
└── 📊 Results: Memory usage reduced by 89%

🔄 PHASE 4: Verification (2 minutes)
├── 🤖 Memory Validator: 24h stability test passed
├── 🤖 Performance Validator: No performance degradation
└── 📊 Results: 95% confidence, ready for production
```

**Entregables**:
- ✅ Memory leak root cause identified
- ✅ Fix implemented with tests
- ✅ Memory monitoring improved
- ✅ Prevention measures added
- ✅ Production deployment plan
- ✅ Rollback strategy ready

---

## 🛠️ Patrones de Uso Avanzados

### **Multi-Approach Parallel Development**

```bash
/ce "resolver problema de concurrencia en chat system" parallel_approaches=true
```

**Beneficios**:
- 🔄 **Múltiples soluciones**: Explora diferentes enfoques simultáneamente
- ⚡ **Comparación objetiva**: Evalúa pros/cons de cada solución
- 🎯 **Mejor resultado**: Combina mejores elementos de cada enfoque
- 🚀 **Desarrollo rápido**: Trabajo paralelo en git worktrees

### **Modo Aprendizaje Continuo**

```bash
# Primera vez
/ce auto "implementar autenticación JWT"

# Subsecuentes usos (más rápido)
/ce auto "implementar autenticación OAuth" # 60% más rápido
/ce auto "implementar autenticación SAML" # 70% más rápido
```

**Ventajas**:
- 📈 **Mejora continua**: Cada uso optimiza futuros comandos
- 🎯 **Patrones personalizados**: Adapta a tu estilo de trabajo
- ⚡ **Velocidad incrementada**: Hasta 70% más rápido con el uso

### **Análisis de Complejidad Automático**

```bash
# El sistema auto-detecta complejidad
/ce "agregar botón"                    # → 2 fases (simple)
/ce "implementar sistema de pagos"     # → 3 fases (medio)
/ce "diseñar arquitectura distribuida" # → 5 fases (complejo)
```

## 📊 Métricas de Rendimiento por Caso de Uso

### **Desarrollo de Features**
- **Tiempo promedio**: 12-18 minutos
- **Tasa de éxito**: 96%
- **Cobertura de tests**: 94%
- **Calidad de código**: 9.2/10

### **Análisis de Código**
- **Tiempo promedio**: 4-8 minutos
- **Comprensión lograda**: 97%
- **Documentación generada**: 100%
- **Actionable insights**: 89%

### **Optimización Performance**
- **Tiempo promedio**: 8-15 minutos
- **Mejora promedio**: 73%
- **Problemas resueltos**: 91%
- **Regresiones**: 0%

### **Arquitectura de Sistemas**
- **Tiempo promedio**: 20-30 minutos
- **Completitud**: 98%
- **Escalabilidad**: 95%
- **Mantenibilidad**: 93%

## 🎯 Tips para Máxima Efectividad

### **Objetivos Claros**
```bash
# ✅ Bueno
/ce "implementar cache Redis para reducir latencia API"

# ❌ Vago
/ce "mejorar performance"
```

### **Contexto Específico**
```bash
# ✅ Mejor
/ce "refactorizar módulo de pagos en Node.js para mejor testabilidad"

# ✅ Bueno
/ce "refactorizar módulo de pagos"
```

### **Usar Hints Cuando Sea Necesario**
```bash
# Para arquitectura compleja
/ce "diseñar microservicios" model=opus

# Para implementación rápida
/ce "agregar validación forms" complexity=low
```

---

**¿Listo para empezar?** Elige un ejemplo similar a tu caso de uso y adapta el comando a tu objetivo específico.

**Siguiente paso**: [Entender el comando principal](/context-eng) para aprovechar al máximo todas las características.