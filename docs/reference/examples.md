# ğŸ“š Ejemplos de Uso

## ğŸ¯ Casos de Uso Reales

### **1. Desarrollo de Nueva Funcionalidad**

#### **Objetivo**: Implementar sistema de notificaciones en tiempo real

```bash
/context-eng "implementar sistema de notificaciones push en tiempo real con WebSockets"
```

**Resultado AutomÃ¡tico**:
```
ğŸ”„ PHASE 0: Intelligent Routing
â”œâ”€â”€ Complexity: 1.4 (Medium-High)
â”œâ”€â”€ Confidence: 0.75
â”œâ”€â”€ Strategy: 5-phase full orchestration
â””â”€â”€ Duration: ~18 minutes estimated

ğŸ”„ PHASE 1: Discovery (4 minutes)
â”œâ”€â”€ ğŸ¤– Knowledge Specialist: Analyzed WebSocket patterns
â”œâ”€â”€ ğŸ¤– Pattern Specialist: Identified notification patterns
â””â”€â”€ ğŸ“Š Results: Architecture recommendations ready

ğŸ”„ PHASE 2: Planning (5 minutes)
â”œâ”€â”€ ğŸ¤– Planning Specialist: TDD approach selected
â”œâ”€â”€ ğŸ¤– Model Specialist: Sonnet recommended (implementation focus)
â””â”€â”€ ğŸ“Š Results: Implementation plan with milestones

ğŸ”„ PHASE 3: Execution (6 minutes)
â”œâ”€â”€ ğŸ¤– Parallel Coordinator: WebSocket + Database + Frontend
â”œâ”€â”€ ğŸ¤– Git Strategist: Feature branch with commit strategy
â””â”€â”€ ğŸ“Š Results: Parallel implementation completed

ğŸ”„ PHASE 4: Verification (2 minutes)
â”œâ”€â”€ ğŸ¤– Test Specialist: 24/24 tests passing
â”œâ”€â”€ ğŸ¤– Performance Specialist: <200ms latency achieved
â””â”€â”€ ğŸ“Š Results: 97% confidence, production ready

ğŸ”„ PHASE 5: Documentation (1 minute)
â”œâ”€â”€ ğŸ¤– Documentation Specialist: API docs generated
â”œâ”€â”€ ğŸ¤– Pattern Specialist: Pattern crystallized for reuse
â””â”€â”€ ğŸ“Š Results: Living documentation updated
```

**Entregables**:
- âœ… WebSocket server implementado
- âœ… Frontend notification components
- âœ… Database schema optimizada
- âœ… Tests completos con 97% coverage
- âœ… DocumentaciÃ³n API generada
- âœ… PatrÃ³n reutilizable creado

---

### **2. AnÃ¡lisis de CÃ³digo Legacy**

#### **Objetivo**: Entender y documentar sistema de facturaciÃ³n legacy

```bash
/ce auto "analizar y documentar el sistema de facturaciÃ³n legacy para refactoring"
```

**Resultado AutomÃ¡tico**:
```
ğŸ”„ ADAPTIVE ROUTING: Learning mode detected
â”œâ”€â”€ Pattern: "analizar" â†’ Quick exploration workflow
â”œâ”€â”€ Confidence: 0.94 (high pattern match)
â”œâ”€â”€ Strategy: 2-phase optimized (70% faster)
â””â”€â”€ Duration: ~6 minutes estimated

ğŸ”„ PHASE 0: Quick Routing (1 minute)
â”œâ”€â”€ Registry Analysis: /quick-explore optimal (94% success rate)
â”œâ”€â”€ Command Selection: Exploration-focused atomic commands
â””â”€â”€ Optimization: Skip planning overhead for analysis tasks

ğŸ”„ PHASE 3: Execution (5 minutes)
â”œâ”€â”€ ğŸ¤– Code Analyzer: Mapped 847 functions, 23 modules
â”œâ”€â”€ ğŸ¤– Dependency Specialist: Identified 12 critical paths
â”œâ”€â”€ ğŸ¤– Documentation Specialist: Generated interaction diagrams
â””â”€â”€ ğŸ“Š Results: Complete system map with refactoring recommendations
```

**Entregables**:
- âœ… System architecture diagram
- âœ… Dependency analysis report
- âœ… Code quality assessment
- âœ… Refactoring priority matrix
- âœ… Risk assessment for changes
- âœ… Migration strategy outline

---

### **3. Performance Optimization**

#### **Objetivo**: Optimizar API que estÃ¡ experimentando latencia alta

```bash
/ce "optimizar API de e-commerce que tiene latencia >2000ms en endpoints crÃ­ticos"
```

**Resultado AutomÃ¡tico**:
```
ğŸ”„ PHASE 0: Intelligent Routing
â”œâ”€â”€ Complexity: 1.2 (Medium)
â”œâ”€â”€ Confidence: 0.82
â”œâ”€â”€ Strategy: 3-phase execution (50% faster)
â””â”€â”€ Duration: ~10 minutes estimated

ğŸ”„ PHASE 0: Routing (1 minute)
â”œâ”€â”€ Decision Engine: Performance optimization pattern detected
â”œâ”€â”€ Parallel Analysis: Database + Code + Infrastructure beneficial
â””â”€â”€ Command Selection: Performance-focused orchestration

ğŸ”„ PHASE 2: Strategic Planning (3 minutes)
â”œâ”€â”€ ğŸ¤– Performance Specialist: Identified N+1 queries, cache misses
â”œâ”€â”€ ğŸ¤– Database Specialist: Index optimization strategy
â”œâ”€â”€ ğŸ¤– Architecture Specialist: Caching layer recommendations
â””â”€â”€ ğŸ“Š Results: Multi-layer optimization plan ready

ğŸ”„ PHASE 3: Execution (6 minutes)
â”œâ”€â”€ ğŸ¤– Query Optimizer: Reduced queries from 45 to 3 per request
â”œâ”€â”€ ğŸ¤– Cache Specialist: Redis implementation with 95% hit rate
â”œâ”€â”€ ğŸ¤– Index Specialist: Database indexes optimized
â””â”€â”€ ğŸ“Š Results: Latency reduced from 2000ms to 180ms
```

**Entregables**:
- âœ… Database queries optimized (15x reduction)
- âœ… Redis caching layer implemented
- âœ… Database indexes created
- âœ… Performance monitoring dashboard
- âœ… Load testing results
- âœ… Production deployment plan

---

### **4. Arquitectura de Microservicios**

#### **Objetivo**: DiseÃ±ar arquitectura completa para plataforma de streaming

```bash
/ce "diseÃ±ar arquitectura de microservicios para plataforma de streaming con 1M+ usuarios" model=opus
```

**Resultado AutomÃ¡tico**:
```
ğŸ”„ PHASE 0: Intelligent Routing
â”œâ”€â”€ Complexity: 1.9 (Ultra-High)
â”œâ”€â”€ Confidence: 0.45 (architecture uncertainty)
â”œâ”€â”€ Strategy: 5-phase complete orchestration + multi-agent
â””â”€â”€ Duration: ~25 minutes estimated

ğŸ”„ PHASE 1: Discovery (6 minutes)
â”œâ”€â”€ ğŸ¤– Domain Specialist: Identified 8 core domains
â”œâ”€â”€ ğŸ¤– Scale Specialist: Analyzed 1M+ user requirements
â”œâ”€â”€ ğŸ¤– Technology Specialist: Evaluated 15 technology options
â”œâ”€â”€ ğŸ¤– Pattern Specialist: Streaming architecture patterns
â””â”€â”€ ğŸ“Š Results: Comprehensive requirements and constraints

ğŸ”„ PHASE 2: Planning (8 minutes)
â”œâ”€â”€ ğŸ¤– Architecture Specialist: Service boundary definitions
â”œâ”€â”€ ğŸ¤– Data Specialist: Event sourcing + CQRS strategy
â”œâ”€â”€ ğŸ¤– Infrastructure Specialist: Kubernetes deployment plan
â”œâ”€â”€ ğŸ¤– Security Specialist: Authentication and authorization
â””â”€â”€ ğŸ“Š Results: Detailed architecture blueprint

ğŸ”„ PHASE 3: Execution (7 minutes)
â”œâ”€â”€ ğŸ¤– Service Designer: 12 microservices designed
â”œâ”€â”€ ğŸ¤– API Designer: OpenAPI specifications created
â”œâ”€â”€ ğŸ¤– Database Designer: Database per service strategy
â”œâ”€â”€ ğŸ¤– DevOps Specialist: CI/CD pipeline architecture
â””â”€â”€ ğŸ“Š Results: Implementation-ready architecture

ğŸ”„ PHASE 4: Verification (3 minutes)
â”œâ”€â”€ ğŸ¤– Architecture Validator: Single points of failure eliminated
â”œâ”€â”€ ğŸ¤– Performance Validator: Load testing scenarios
â”œâ”€â”€ ğŸ¤– Security Validator: Threat modeling completed
â””â”€â”€ ğŸ“Š Results: 98% confidence, production-ready design

ğŸ”„ PHASE 5: Documentation (1 minute)
â”œâ”€â”€ ğŸ¤– Documentation Specialist: Architecture decision records
â”œâ”€â”€ ğŸ¤– Diagram Specialist: C4 model diagrams generated
â””â”€â”€ ğŸ“Š Results: Complete architecture documentation
```

**Entregables**:
- âœ… 12 microservices architecture
- âœ… API gateway configuration
- âœ… Database design (per service)
- âœ… Event streaming architecture
- âœ… Security implementation plan
- âœ… Monitoring and observability
- âœ… Deployment infrastructure
- âœ… Scaling strategy (1M+ users)

---

### **5. Bug Fixing CrÃ­tico**

#### **Objetivo**: Resolver memory leak en producciÃ³n

```bash
/ce "encontrar y corregir memory leak crÃ­tico en aplicaciÃ³n Node.js en producciÃ³n"
```

**Resultado AutomÃ¡tico**:
```
ğŸ”„ PHASE 0: Intelligent Routing
â”œâ”€â”€ Complexity: 1.3 (Medium-High)
â”œâ”€â”€ Confidence: 0.68 (debugging uncertainty)
â”œâ”€â”€ Strategy: 5-phase with emphasis on discovery
â””â”€â”€ Duration: ~15 minutes estimated

ğŸ”„ PHASE 1: Discovery (5 minutes)
â”œâ”€â”€ ğŸ¤– Memory Specialist: Heap dump analysis
â”œâ”€â”€ ğŸ¤– Code Specialist: Event listener audit
â”œâ”€â”€ ğŸ¤– Performance Specialist: Memory usage patterns
â””â”€â”€ ğŸ“Š Results: Memory leak in WebSocket connections identified

ğŸ”„ PHASE 2: Planning (2 minutes)
â”œâ”€â”€ ğŸ¤– Strategy Specialist: Hot-fix vs comprehensive fix
â”œâ”€â”€ ğŸ¤– Risk Specialist: Production impact assessment
â””â”€â”€ ğŸ“Š Results: Staged rollout plan with rollback strategy

ğŸ”„ PHASE 3: Execution (6 minutes)
â”œâ”€â”€ ğŸ¤– Fix Specialist: Connection cleanup implemented
â”œâ”€â”€ ğŸ¤– Test Specialist: Memory leak tests added
â”œâ”€â”€ ğŸ¤– Monitor Specialist: Memory monitoring enhanced
â””â”€â”€ ğŸ“Š Results: Memory usage reduced by 89%

ğŸ”„ PHASE 4: Verification (2 minutes)
â”œâ”€â”€ ğŸ¤– Memory Validator: 24h stability test passed
â”œâ”€â”€ ğŸ¤– Performance Validator: No performance degradation
â””â”€â”€ ğŸ“Š Results: 95% confidence, ready for production
```

**Entregables**:
- âœ… Memory leak root cause identified
- âœ… Fix implemented with tests
- âœ… Memory monitoring improved
- âœ… Prevention measures added
- âœ… Production deployment plan
- âœ… Rollback strategy ready

---

## ğŸ› ï¸ Patrones de Uso Avanzados

### **Multi-Approach Parallel Development**

```bash
/ce "resolver problema de concurrencia en chat system" parallel_approaches=true
```

**Beneficios**:
- ğŸ”„ **MÃºltiples soluciones**: Explora diferentes enfoques simultÃ¡neamente
- âš¡ **ComparaciÃ³n objetiva**: EvalÃºa pros/cons de cada soluciÃ³n
- ğŸ¯ **Mejor resultado**: Combina mejores elementos de cada enfoque
- ğŸš€ **Desarrollo rÃ¡pido**: Trabajo paralelo en git worktrees

### **Modo Aprendizaje Continuo**

```bash
# Primera vez
/ce auto "implementar autenticaciÃ³n JWT"

# Subsecuentes usos (mÃ¡s rÃ¡pido)
/ce auto "implementar autenticaciÃ³n OAuth" # 60% mÃ¡s rÃ¡pido
/ce auto "implementar autenticaciÃ³n SAML" # 70% mÃ¡s rÃ¡pido
```

**Ventajas**:
- ğŸ“ˆ **Mejora continua**: Cada uso optimiza futuros comandos
- ğŸ¯ **Patrones personalizados**: Adapta a tu estilo de trabajo
- âš¡ **Velocidad incrementada**: Hasta 70% mÃ¡s rÃ¡pido con el uso

### **AnÃ¡lisis de Complejidad AutomÃ¡tico**

```bash
# El sistema auto-detecta complejidad
/ce "agregar botÃ³n"                    # â†’ 2 fases (simple)
/ce "implementar sistema de pagos"     # â†’ 3 fases (medio)
/ce "diseÃ±ar arquitectura distribuida" # â†’ 5 fases (complejo)
```

## ğŸ“Š MÃ©tricas de Rendimiento por Caso de Uso

### **Desarrollo de Features**
- **Tiempo promedio**: 12-18 minutos
- **Tasa de Ã©xito**: 96%
- **Cobertura de tests**: 94%
- **Calidad de cÃ³digo**: 9.2/10

### **AnÃ¡lisis de CÃ³digo**
- **Tiempo promedio**: 4-8 minutos
- **ComprensiÃ³n lograda**: 97%
- **DocumentaciÃ³n generada**: 100%
- **Actionable insights**: 89%

### **OptimizaciÃ³n Performance**
- **Tiempo promedio**: 8-15 minutos
- **Mejora promedio**: 73%
- **Problemas resueltos**: 91%
- **Regresiones**: 0%

### **Arquitectura de Sistemas**
- **Tiempo promedio**: 20-30 minutos
- **Completitud**: 98%
- **Escalabilidad**: 95%
- **Mantenibilidad**: 93%

## ğŸ¯ Tips para MÃ¡xima Efectividad

### **Objetivos Claros**
```bash
# âœ… Bueno
/ce "implementar cache Redis para reducir latencia API"

# âŒ Vago
/ce "mejorar performance"
```

### **Contexto EspecÃ­fico**
```bash
# âœ… Mejor
/ce "refactorizar mÃ³dulo de pagos en Node.js para mejor testabilidad"

# âœ… Bueno
/ce "refactorizar mÃ³dulo de pagos"
```

### **Usar Hints Cuando Sea Necesario**
```bash
# Para arquitectura compleja
/ce "diseÃ±ar microservicios" model=opus

# Para implementaciÃ³n rÃ¡pida
/ce "agregar validaciÃ³n forms" complexity=low
```

---

**Â¿Listo para empezar?** Elige un ejemplo similar a tu caso de uso y adapta el comando a tu objetivo especÃ­fico.

**Siguiente paso**: [Entender el comando principal](/context-eng) para aprovechar al mÃ¡ximo todas las caracterÃ­sticas.